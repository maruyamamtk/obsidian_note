# 詳細_第4章 連続最適化で広告予算を配分する

#連続最適化 #広告予算配分 #複数メディア #ユニークリーチ #UniqueReachEstimator #TotalReachEstimator

## 複数メディアにおける広告予算の連続最適化

この章では、テレビCMやデジタル広告など、**複数のメディアにまたがる広告予算の「連続最適化」配分**について詳細に解説しています。

## 最適化の目標

**総広告費の制約のもとで、複数のメディアを組み合わせたユニークリーチ（広告到達人数）を最大化**することが主要な目標です。

## ステップ1：広告予算配分問題の数理定式化

### 多変数最適化問題

複数メディアへの予算配分を最適化問題として定式化：

$$\max E[R_{1,2}|g_1, g_2]$$

subject to:
$$\sum_{j} c_j g_j \leq b$$
$$g_j \geq 0 \quad \forall j$$

where:
- **決定変数**：$g_j$（各メディア$j$への出稿量）
- **目的関数**：$E[R_{1,2}|g_1, g_2]$（全体のユニークリーチ）
- **制約条件**：$\sum c_j g_j \leq b$（総予算制約）

### 連続最適化の特徴

離散最適化と異なり、出稿量を連続的な値として扱うことで：

1. **微細な調整**が可能
2. **勾配ベース**の最適化アルゴリズムが適用可能
3. **局所最適解**への収束が保証される

## ステップ2：複数メディアのリーチ関係モデリング

### 個別メディアのリーチ推定

#### Random Forestによる非線形モデリング

各メディアのグロスリーチとユニークリーチの関係：

```python
from sklearn.ensemble import RandomForestRegressor

# メディア1のリーチ予測
rf_model_1 = RandomForestRegressor(n_estimators=100)
rf_model_1.fit(gross_reach_1, unique_reach_1)

# メディア2のリーチ予測  
rf_model_2 = RandomForestRegressor(n_estimators=100)
rf_model_2.fit(gross_reach_2, unique_reach_2)
```

#### Linear Regressionによる線形近似

単純な線形関係を仮定した場合：

$$r_j(g_j) = \alpha_j + \beta_j g_j$$

### メディア間のリーチ重複モデリング

#### 独立性仮定による近似

複数メディアのユニークリーチを以下の式でモデル化：

$$r_{1,2}(g_1, g_2) = r_1(g_1) + r_2(g_2) - r_1(g_1)r_2(g_2)$$

この式は以下の確率論的解釈に基づきます：

$$P(A \cup B) = P(A) + P(B) - P(A \cap B)$$

ここで、$P(A \cap B) = P(A)P(B)$（独立性仮定）

#### より複雑な重複パターン

実際のメディア間相関を考慮した場合：

$$r_{1,2}(g_1, g_2) = r_1(g_1) + r_2(g_2) - \rho \cdot r_1(g_1) \cdot r_2(g_2)$$

where $\rho$：メディア間の相関係数

### Pythonクラスによる実装

#### UniqueReachEstimatorクラス

個別メディアのユニークリーチ推定：

```python
class UniqueReachEstimator:
    def __init__(self, model_type='random_forest'):
        self.model_type = model_type
        self.model = None
        
    def fit(self, gross_reach, unique_reach):
        if self.model_type == 'random_forest':
            self.model = RandomForestRegressor()
        elif self.model_type == 'linear':
            self.model = LinearRegression()
        
        self.model.fit(gross_reach.reshape(-1, 1), unique_reach)
    
    def predict(self, gross_reach):
        return self.model.predict(gross_reach.reshape(-1, 1))
```

#### TotalReachEstimatorクラス

複合メディアのユニークリーチ推定：

```python
class TotalReachEstimator:
    def __init__(self):
        self.media_estimators = {}
        self.overlap_coefficient = 1.0
        
    def add_media(self, media_name, estimator):
        self.media_estimators[media_name] = estimator
    
    def fit_overlap(self, multi_media_data):
        # メディア間重複の学習
        pass
    
    def predict_total_reach(self, gross_reaches):
        individual_reaches = []
        for media, gross in gross_reaches.items():
            reach = self.media_estimators[media].predict([gross])[0]
            individual_reaches.append(reach)
        
        # 重複を考慮した総リーチ計算
        total_reach = self._calculate_combined_reach(individual_reaches)
        return total_reach
    
    def _calculate_combined_reach(self, reaches):
        if len(reaches) == 2:
            r1, r2 = reaches[0], reaches[1]
            return r1 + r2 - self.overlap_coefficient * r1 * r2
        # 3つ以上のメディアの場合の拡張
        pass
```

## REVISIO社データによる実証分析

### データ構造

実際のマルチメディアキャンペーンデータ：

1. **テレビCMデータ**
   - 出稿量（GRP）
   - 到達人数
   - コスト

2. **デジタル広告データ**
   - インプレッション数
   - ユニークリーチ
   - クリック率

3. **クロスメディアデータ**
   - 重複視聴者数
   - 相乗効果指標

### モデル精度の検証

交差検証による予測精度評価：

```python
from sklearn.model_selection import cross_val_score

# Random Forestの精度評価
rf_scores = cross_val_score(rf_model, X, y, cv=5, scoring='r2')
print(f"Random Forest R²: {rf_scores.mean():.3f} ± {rf_scores.std():.3f}")

# Linear Regressionの精度評価  
lr_scores = cross_val_score(lr_model, X, y, cv=5, scoring='r2')
print(f"Linear Regression R²: {lr_scores.mean():.3f} ± {lr_scores.std():.3f}")
```

## ステップ3：連続最適化による予算配分決定

### Scipyを用いた制約付き最適化

```python
from scipy.optimize import minimize

def objective_function(allocation):
    """最大化したいユニークリーチの負値を返す"""
    g1, g2 = allocation[0], allocation[1]
    
    # 各メディアの個別リーチ
    reach1 = media1_estimator.predict([g1])[0]
    reach2 = media2_estimator.predict([g2])[0]
    
    # 重複を考慮した総リーチ
    total_reach = reach1 + reach2 - reach1 * reach2
    
    return -total_reach  # 最小化問題として扱うため負値

def budget_constraint(allocation):
    """予算制約"""
    g1, g2 = allocation[0], allocation[1]
    total_cost = cost1 * g1 + cost2 * g2
    return budget - total_cost

# 制約条件の定義
constraints = [
    {'type': 'ineq', 'fun': budget_constraint},
]

# 境界条件（非負制約）
bounds = [(0, None), (0, None)]

# 最適化実行
initial_guess = [budget/(2*cost1), budget/(2*cost2)]
result = minimize(objective_function, 
                 initial_guess,
                 method='SLSQP',
                 bounds=bounds,
                 constraints=constraints)

optimal_allocation = result.x
```

### ラグランジュ乗数法による解析的解法

制約条件が単純な場合、解析的に最適解を求めることも可能：

$$L = r_1(g_1) + r_2(g_2) - r_1(g_1)r_2(g_2) - \lambda(c_1g_1 + c_2g_2 - b)$$

最適性条件：
$$\frac{\partial L}{\partial g_1} = r_1'(g_1)(1 - r_2(g_2)) - \lambda c_1 = 0$$
$$\frac{\partial L}{\partial g_2} = r_2'(g_2)(1 - r_1(g_1)) - \lambda c_2 = 0$$

## 実用的な拡張と応用

### 時系列を考慮した動的最適化

キャンペーン期間中の予算配分を動的に調整：

1. **期間分割**による逐次最適化
2. **学習効果**を考慮したモデル更新
3. **外部要因**（競合他社の活動等）の取り込み

### 多目的最適化

複数の指標を同時に最適化：

- **ユニークリーチ**の最大化
- **ブランド認知**の向上  
- **購買意向**の促進
- **コスト効率**の改善

### 不確実性を考慮したロバスト最適化

モデル予測の不確実性を考慮：

$$\max \min_{\theta \in \Theta} E[R_{1,2}|g_1, g_2, \theta]$$

ここで$\Theta$はパラメータの不確実性集合

## 実務への実装

### A/Bテストによる効果検証

最適化結果の実務検証：

1. **統制群**：従来の配分方法
2. **実験群**：最適化による配分
3. **効果測定**：リーチ、認知、売上等の比較

### レポーティングシステム

継続的なモニタリングと改善：

- **ダッシュボード**による可視化
- **アラート機能**による異常検知
- **自動レポート**生成システム

---

**戻る**：[[章ごとのまとめ]]

**前章**：[[詳細_第3章 認知形成を数理モデリングする]]

**次章**：[[詳細_第5章 離散最適化で広告出稿番組を選択する]]
