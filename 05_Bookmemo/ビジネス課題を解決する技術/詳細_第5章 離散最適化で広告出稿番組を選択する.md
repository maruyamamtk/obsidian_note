# 詳細_第5章 離散最適化で広告出稿番組を選択する

#離散最適化 #番組選択 #貪欲法 #シャプレー値 #ProgramUniqueReachEstimator #組み合わせ最適化

## テレビ番組への広告出稿の離散最適化

この章では、特定のテレビ番組への広告出稿を個別に選択する**「離散最適化」の課題**に焦点を当て、予算制約のもとで最も多くのユニークリーチを獲得できる番組の組み合わせを特定する手法を解説しています。

## 離散最適化と連続最適化の違い

### 離散最適化の特徴

- **決定変数**：出稿する/しない の二値選択
- **解空間**：有限個の組み合わせ
- **計算複雑性**：NP困難問題となる場合が多い

### 連続最適化との対比

| 項目 | 連続最適化 | 離散最適化 |
|------|------------|------------|
| 決定変数 | 連続値（出稿量） | 離散値（0/1） |
| 解法 | 勾配法、ニュートン法 | 動的計画法、貪欲法 |
| 計算量 | 多項式時間 | 指数時間（多くの場合） |

## ステップ1：番組選択問題の数理定式化

### 0-1ナップサック問題としての定式化

番組選択問題を以下の最適化問題として定式化：

$$\max E[R|d]$$

subject to:
$$\sum_{j=1}^{m} c_j d_j \leq b$$
$$d_j \in \{0, 1\} \quad \forall j = 1, \ldots, m$$

where:
- **決定変数**：$d_j \in \{0, 1\}$（番組$j$への出稿の有無）
- **目的関数**：$E[R|d]$（選択した番組群のユニークリーチ）
- **制約条件**：$\sum c_j d_j \leq b$（総予算制約）
- **$c_j$**：番組$j$の出稿コスト
- **$b$**：利用可能な総予算

### 問題の複雑性

番組数を$m$とすると、可能な組み合わせは$2^m$通り存在し、最適解の探索には指数時間が必要となります。

## ステップ2：番組間リーチ重複を考慮したモデル構築

### 個人レベルのCM接触確率モデリング

個人$i$が番組$j$でCMに接触する確率を$p_{ij}$とし、番組選択パターン$d$に対するユニークリーチを以下のように表現：

$$E[R|d] = \sum_{i=1}^{n} \left(1 - \prod_{j=1}^{m} (1 - p_{ij})^{d_j}\right)$$

この式は、個人$i$が少なくとも1つの選択された番組でCMに接触する確率を全個人について合計したものです。

### 機械学習モデルによる接触確率推定

#### Random Forestによる非線形モデリング

```python
from sklearn.ensemble import RandomForestClassifier

# 個人属性を特徴量として番組接触確率を予測
rf_contact = RandomForestClassifier(n_estimators=100)
rf_contact.fit(user_features, contact_labels)

# 接触確率の予測
contact_probs = rf_contact.predict_proba(user_features)[:, 1]
```

#### Ridge回帰による線形モデル

```python
from sklearn.linear_model import Ridge

ridge_model = Ridge(alpha=1.0)
ridge_model.fit(user_features, contact_rates)
```

### 番組群のユニークリーチ推定

複数番組に同時出稿する際のユニークリーチは以下の確率計算で求められます：

$$E[R|D] = \sum_{x} Pr(X=x) \cdot \left(1 - \prod_{j=1}^{m} (1 - Pr(R_j=1|X=x))^{d_j}\right)$$

where:
- $X$：個人属性ベクトル
- $Pr(X=x)$：属性$x$を持つ個人の割合
- $Pr(R_j=1|X=x)$：属性$x$の個人が番組$j$でCMに接触する確率

### ProgramUniqueReachEstimatorクラス

番組選択に特化したユニークリーチ推定クラス：

```python
class ProgramUniqueReachEstimator:
    def __init__(self):
        self.contact_models = {}
        self.user_segments = None
        
    def fit(self, program_data, user_data, contact_data):
        """
        番組ごとの接触確率モデルを学習
        """
        # ユーザーセグメンテーション
        self.user_segments = self._segment_users(user_data)
        
        # 番組ごとのモデル学習
        for program_id in program_data['program_id'].unique():
            program_contact = contact_data[
                contact_data['program_id'] == program_id
            ]
            
            model = RandomForestClassifier()
            model.fit(user_data, program_contact['contacted'])
            self.contact_models[program_id] = model
    
    def predict_unique_reach(self, program_selection):
        """
        選択された番組群のユニークリーチを予測
        """
        total_reach = 0
        
        for segment, users in self.user_segments.items():
            # セグメント内の個人が少なくとも1番組に接触する確率
            no_contact_prob = 1.0
            
            for program_id in program_selection:
                if program_id in self.contact_models:
                    contact_prob = self.contact_models[program_id].predict_proba(
                        users.features
                    )[:, 1].mean()
                    no_contact_prob *= (1 - contact_prob)
            
            segment_reach = len(users) * (1 - no_contact_prob)
            total_reach += segment_reach
        
        return total_reach
    
    def _segment_users(self, user_data):
        """ユーザーをセグメント化"""
        # 年齢、性別、地域などによるセグメンテーション
        pass
```

## ステップ3：離散最適化による番組選択

### 貪欲法による近似解法

厳密解の計算が困難な場合、貪欲法による効率的な近似解法を適用：

```python
def greedy_program_selection(programs, budget, reach_estimator):
    """
    貪欲法による番組選択
    """
    selected_programs = []
    remaining_budget = budget
    remaining_programs = programs.copy()
    
    while remaining_budget > 0 and remaining_programs:
        best_ratio = 0
        best_program = None
        
        for program in remaining_programs:
            if program['cost'] <= remaining_budget:
                # 現在の選択に新番組を追加した場合のリーチ増分
                current_reach = reach_estimator.predict_unique_reach(
                    selected_programs
                )
                new_reach = reach_estimator.predict_unique_reach(
                    selected_programs + [program['id']]
                )
                
                reach_increment = new_reach - current_reach
                cost_efficiency = reach_increment / program['cost']
                
                if cost_efficiency > best_ratio:
                    best_ratio = cost_efficiency
                    best_program = program
        
        if best_program:
            selected_programs.append(best_program['id'])
            remaining_budget -= best_program['cost']
            remaining_programs.remove(best_program)
        else:
            break
    
    return selected_programs
```

### 動的計画法による厳密解法

番組数が比較的少ない場合の厳密解法：

```python
def exact_program_selection(programs, budget, reach_estimator):
    """
    動的計画法による厳密解
    """
    n = len(programs)
    dp = {}  # メモ化用辞書
    
    def solve(index, remaining_budget):
        if index == n:
            return 0, []
        
        if (index, remaining_budget) in dp:
            return dp[(index, remaining_budget)]
        
        # 現在の番組を選択しない場合
        no_select_reach, no_select_programs = solve(index + 1, remaining_budget)
        
        # 現在の番組を選択する場合
        current_program = programs[index]
        if current_program['cost'] <= remaining_budget:
            select_reach, select_programs = solve(
                index + 1, 
                remaining_budget - current_program['cost']
            )
            
            # 番組追加によるリーチ計算
            new_selection = select_programs + [current_program['id']]
            total_reach = reach_estimator.predict_unique_reach(new_selection)
            
            if total_reach > no_select_reach:
                dp[(index, remaining_budget)] = (total_reach, new_selection)
                return total_reach, new_selection
        
        dp[(index, remaining_budget)] = (no_select_reach, no_select_programs)
        return no_select_reach, no_select_programs
    
    optimal_reach, optimal_selection = solve(0, budget)
    return optimal_selection
```

## シャプレー値による貢献度分析

### シャプレー値の理論的背景

シャプレー値$\phi_i$は、プレイヤー$i$がゲームに参加した際の貢献度を定量化する概念です：

$$\phi_i = \sum_{S \subseteq N \setminus \{i\}} \frac{|S|!(|N|-|S|-1)!}{|N|!}[v(S \cup \{i\}) - v(S)]$$

where:
- $N$：全プレイヤー集合（全番組）
- $S$：プレイヤー$i$を含まない部分集合
- $v(S)$：集合$S$の価値関数（ユニークリーチ）

### 番組選択におけるシャプレー値計算

```python
import itertools
from math import factorial

def calculate_shapley_values(selected_programs, reach_estimator):
    """
    選択された番組群の各番組のシャプレー値を計算
    """
    n = len(selected_programs)
    shapley_values = {}
    
    for target_program in selected_programs:
        shapley_value = 0
        other_programs = [p for p in selected_programs if p != target_program]
        
        # すべての部分集合について計算
        for r in range(len(other_programs) + 1):
            for subset in itertools.combinations(other_programs, r):
                subset_list = list(subset)
                
                # 対象番組なしのリーチ
                reach_without = reach_estimator.predict_unique_reach(subset_list)
                
                # 対象番組ありのリーチ
                reach_with = reach_estimator.predict_unique_reach(
                    subset_list + [target_program]
                )
                
                # 貢献度
                marginal_contribution = reach_with - reach_without
                
                # 重み計算
                subset_size = len(subset)
                weight = (factorial(subset_size) * 
                         factorial(n - subset_size - 1)) / factorial(n)
                
                shapley_value += weight * marginal_contribution
        
        shapley_values[target_program] = shapley_value
    
    return shapley_values
```

### 貢献度に基づく意思決定支援

シャプレー値分析により以下が可能になります：

1. **効果の低い番組**の特定と除外
2. **相乗効果の高い番組組み合わせ**の発見
3. **予算再配分**の優先順位決定

## 実用的な拡張と応用

### リアルタイム最適化

放送スケジュールの変更に対応した動的な番組選択：

1. **番組枠の空き情報**の更新
2. **競合他社の出稿状況**の考慮
3. **視聴率予測**の反映

### 多期間最適化

キャンペーン期間全体を通じた番組選択戦略：

$$\max \sum_{t=1}^{T} E[R_t|d_t]$$

subject to:
$$\sum_{t=1}^{T} \sum_{j=1}^{m} c_{tj} d_{tj} \leq B$$

### 不確実性下での頑健な選択

視聴率やコストの不確実性を考慮したロバスト最適化：

$$\max \min_{\omega \in \Omega} E[R|d, \omega]$$

where $\Omega$は不確実性パラメータの集合

## 実装上の考慮事項

### 計算効率の改善

- **並列計算**による高速化
- **近似アルゴリズム**の適用
- **メモ化技法**による重複計算の回避

### データ品質の管理

- **欠損データ**の補完手法
- **外れ値**の検出と処理
- **データ鮮度**の管理

---

**戻る**：[[章ごとのまとめ]]

**前章**：[[詳細_第4章 連続最適化で広告予算を配分する]]

**関連項目**：
- [[詳細_第1章 ビジネス課題を解決する技術]]（3ステップフレームワーク）
- [[詳細_第2章 マーケティングにデータサイエンスを導入する]]（基本的なCM最適化）
